AT_BANNER([ofproto])

AT_SETUP([ofproto - echo request])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn probe br0])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - feature request, config request])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn show br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPT_FEATURES_REPLY (OF1.2): dpid:fedcba9876543210
n_tables:255, n_buffers:256
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS
actions: OUTPUT COPY_TTL_OUT COPY_TTL_IN SET_MPLS_TTL DEC_MPLS_TTL PUSH_VLAN POP_VLAN PUSH_MPLS POP_MPLS SET_QUEUE GROUP SET_NW_TTL DEC_NW_TTL SET_FIELD
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 100000 Mbps now, 100000 Mbps max
OFPT_GET_CONFIG_REPLY (OF1.2): frags=normal miss_send_len=0
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - port stats])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn dump-ports br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_PORT reply (OF1.2): 1 ports
  port 4294967294: rx pkts=0, bytes=0, drop=0, errs=0, frame=0, over=0, crc=0
           tx pkts=0, bytes=0, drop=0, errs=0, coll=0
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - port-desc stats])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn dump-ports-desc br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_PORT_DESC reply (OF1.2):
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 100000 Mbps now, 100000 Mbps max
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This is really bare-bones.
dnl It at least checks request and reply serialization and deserialization.
AT_SETUP([ofproto - queue stats])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl -vwarn queue-stats br0], [0], [stdout])
AT_CHECK([STRIP_XIDS stdout], [0], [dnl
OFPST_QUEUE reply (OF1.2): 0 queues
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - mod-port])
OVS_VSWITCHD_START
for command_config_state in \
    'up 0 0' \
    'down PORT_DOWN LINK_DOWN' \
    'flood PORT_DOWN LINK_DOWN' \
    'no-receive PORT_DOWN,NO_RECV LINK_DOWN' \
    'no-forward PORT_DOWN,NO_RECV,NO_FWD LINK_DOWN' \
    'no-packet-in PORT_DOWN,NO_RECV,NO_FWD,NO_PACKET_IN LINK_DOWN' \
    'forward PORT_DOWN,NO_RECV,NO_PACKET_IN LINK_DOWN' \
    'packet-in PORT_DOWN,NO_RECV LINK_DOWN' \
    'up NO_RECV 0' \
    'receive 0 0'
do
    set $command_config_state
    command=$[1] config=`echo $[2] | sed 's/,/ /g'` state=$[3]
    AT_CHECK([ovs-ofctl -vwarn mod-port br0 br0 $command])
    AT_CHECK([ovs-ofctl -vwarn show br0], [0], [stdout])
    AT_CHECK_UNQUOTED([STRIP_XIDS stdout], [0], [dnl
OFPT_FEATURES_REPLY (OF1.2): dpid:fedcba9876543210
n_tables:255, n_buffers:256
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS
actions: OUTPUT COPY_TTL_OUT COPY_TTL_IN SET_MPLS_TTL DEC_MPLS_TTL PUSH_VLAN POP_VLAN PUSH_MPLS POP_MPLS SET_QUEUE GROUP SET_NW_TTL DEC_NW_TTL SET_FIELD
 LOCAL(br0): addr:aa:55:aa:55:00:00
     config:     $config
     state:      $state
     speed: 100000 Mbps now, 100000 Mbps max
OFPT_GET_CONFIG_REPLY (OF1.2): frags=normal miss_send_len=0
])
done
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - basic flow_mod commands (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [OFPST11_FLOW reply (OF1.2):
])
AT_CHECK([echo 'in_port=1,actions=0' | ovs-ofctl add-flows br0 -])
AT_CHECK([ovs-ofctl add-flow br0 in_port=0,actions=1])
AT_CHECK([ovs-ofctl add-flow br0 table=1,in_port=3,actions=2])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=0 actions=apply_actions(output:1)
 in_port=1 actions=apply_actions(output:0)
 table=1, in_port=3 actions=apply_actions(output:2)
OFPST11_FLOW reply (OF1.2):
])
AT_CHECK([ovs-ofctl dump-aggregate br0 table=0 | STRIP_XIDS], [0], [dnl
OFPST11_AGGREGATE reply (OF1.2): packet_count=0 byte_count=0 flow_count=2
])
AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip], [0], [OFPST11_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - del flows with cookies])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x1,in_port=1,actions=0])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x2,in_port=2,actions=0])
AT_CHECK([ovs-ofctl add-flow br0 cookie=0x3,in_port=3,actions=0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, in_port=1 actions=apply_actions(output:0)
 cookie=0x2, in_port=2 actions=apply_actions(output:0)
 cookie=0x3, in_port=3 actions=apply_actions(output:0)
OFPST11_FLOW reply (OF1.2):
])

AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
OFPST11_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - flow table configuration])
OVS_VSWITCHD_START
# Check the default configuration.
(head="wild=0x003ff, max=1000000,"
 tail="               lookup=0, matched=0
               match=000003ff, instructions=00000007, config=00000000
               write_actions=00000000, apply_actions=00000000
               write_setfields=0000003f00000000
               apply_setfields=0000003f00000000
               metadata_match=0000000000000000
               metadata_write=0000000000000000"
 echo "OFPST_TABLE reply (OF1.2) (xid=0x2): 255 tables
  0: classifier: $head active=0
$tail"
 x=1
 while test $x -lt 254; do
   printf "  %d: %-8s: $head active=0
$tail
" $x table$x
   x=`expr $x + 1`
 done
 echo "  254: table254: $head active=2
$tail") > expout
AT_CHECK([ovs-ofctl dump-tables br0], [0], [expout])
# Change the configuration.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=main \
     -- --id=@t1 create Flow_Table flow-limit=1024 \
     -- set bridge br0 'flow_tables={1=@t1,0=@t0}' \
   | perl $srcdir/uuidfilt.pl],
  [0], [<0>
<1>
])
# Check that the configuration was updated.
mv expout orig-expout
(tail="               lookup=0, matched=0
               match=000003ff, instructions=00000007, config=00000000
               write_actions=00000000, apply_actions=00000000
               write_setfields=0000003f00000000
               apply_setfields=0000003f00000000
               metadata_match=0000000000000000
               metadata_write=0000000000000000"
 echo "OFPST_TABLE reply (OF1.2) (xid=0x2): 255 tables
  0: main    : wild=0x003ff, max=1000000, active=0
$tail
  1: table1  : wild=0x003ff, max=  1024, active=0
$tail"
 tail -n +18 orig-expout) > expout
AT_CHECK([ovs-ofctl dump-tables br0], [0], [expout])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - hard limits on flow table size])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 \
     -- set bridge br0 flow_tables:0=@t0 \
   | perl $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
for in_port in 1 2 3 4; do
    ovs-ofctl add-flow br0 in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=apply_actions(drop)
 in_port=2 actions=apply_actions(drop)
 in_port=3 actions=apply_actions(drop)
 in_port=4 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# Adding another flow will be refused.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop], [1], [], [stderr])
AT_CHECK([head -n 1 stderr | ofctl_strip], [0],
  [OFPT_ERROR (OF1.2): OFPFMFC_TABLE_FULL
])
# In Open Flow 1.2 a mod-flow does not ever add a flow and thus
# has no effect on eviction
AT_CHECK([ovs-ofctl mod-flows br0 in_port=5,actions=drop], [0], [], [])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=apply_actions(drop)
 in_port=2 actions=apply_actions(drop)
 in_port=3 actions=apply_actions(drop)
 in_port=4 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# Replacing or modifying an existing flow is allowed.
AT_CHECK([ovs-ofctl add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=1 actions=apply_actions(drop)
 in_port=2 actions=apply_actions(drop)
 in_port=3 actions=apply_actions(output:1)
 in_port=4 actions=apply_actions(NORMAL)
OFPST11_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table flow-limit=4 overflow-policy=evict \
     -- set bridge br0 flow_tables:0=@t0 \
   | perl $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
for in_port in 4 3 2 1; do
    ovs-ofctl add-flow br0 idle_timeout=${in_port}0,in_port=$in_port,actions=drop
done
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=1 actions=apply_actions(drop)
 idle_timeout=20, in_port=2 actions=apply_actions(drop)
 idle_timeout=30, in_port=3 actions=apply_actions(drop)
 idle_timeout=40, in_port=4 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=5,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=20, in_port=2 actions=apply_actions(drop)
 idle_timeout=30, in_port=3 actions=apply_actions(drop)
 idle_timeout=40, in_port=4 actions=apply_actions(drop)
 in_port=5 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# In Open Flow 1.2 a mod-flow does not ever add a flow and thus
# has no effect on eviction
AT_CHECK([ovs-ofctl mod-flows br0 in_port=6,actions=drop])
AT_CHECK([ovs-ofctl add-flow br0 in_port=4,actions=normal])
AT_CHECK([ovs-ofctl mod-flows br0 in_port=3,actions=output:1])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=20, in_port=2 actions=apply_actions(drop)
 idle_timeout=30, in_port=3 actions=apply_actions(output:1)
 in_port=4 actions=apply_actions(NORMAL)
 in_port=5 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# Flows with no timeouts at all cannot be evicted.
AT_CHECK([ovs-ofctl add-flow br0 in_port=6,actions=drop])
AT_CHECK([ovs-ofctl add-flow br0 in_port=7,actions=normal])
AT_CHECK([ovs-ofctl add-flow br0 in_port=8,actions=drop], [1], [], [stderr])
AT_CHECK([head -n 1 stderr | ofctl_strip], [0],
  [OFPT_ERROR (OF1.2): OFPFMFC_TABLE_FULL
])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 in_port=4 actions=apply_actions(NORMAL)
 in_port=5 actions=apply_actions(drop)
 in_port=6 actions=apply_actions(drop)
 in_port=7 actions=apply_actions(NORMAL)
OFPST11_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - eviction upon table overflow, with fairness])
OVS_VSWITCHD_START
# Configure a maximum of 4 flows.
AT_CHECK(
  [ovs-vsctl \
     -- --id=@t0 create Flow_Table name=evict flow-limit=4 \
                                   overflow-policy=evict \
                                   groups='"NXM_OF_IN_PORT[[]]"' \
     -- set bridge br0 flow_tables:0=@t0 \
   | perl $srcdir/uuidfilt.pl],
  [0], [<0>
])
# Add 4 flows.
ovs-ofctl add-flows br0 - <<EOF
idle_timeout=10 in_port=2 dl_src=00:44:55:66:77:88 actions=drop
idle_timeout=20 in_port=1 dl_src=00:11:22:33:44:55 actions=drop
idle_timeout=30 in_port=1 dl_src=00:22:33:44:55:66 actions=drop
idle_timeout=40 in_port=1 dl_src=00:33:44:55:66:77 actions=drop
EOF
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=apply_actions(drop)
 idle_timeout=20, in_port=1,dl_src=00:11:22:33:44:55 actions=apply_actions(drop)
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=apply_actions(drop)
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest within
# the largest group (those with in_port=1) to be evicted.  In this
# case this is not the same as the one that expires soonest overall
# (which is what makes the test interesting):
AT_CHECK([ovs-ofctl add-flow br0 in_port=2,dl_src=00:55:66:77:88:99,actions=drop])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=apply_actions(drop)
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=apply_actions(drop)
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=apply_actions(drop)
 in_port=2,dl_src=00:55:66:77:88:99 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# Enlarge the flow limit, change the eviction policy back to strictly
# based on expiration, and and add some flows.
AT_CHECK([ovs-vsctl set Flow_Table evict groups='[[]]' flow-limit=7])
ovs-ofctl add-flows br0 - <<EOF
idle_timeout=50 in_port=2 dl_src=00:66:77:88:99:aa actions=drop
idle_timeout=60 in_port=2 dl_src=00:77:88:99:aa:bb actions=drop
idle_timeout=70 in_port=2 dl_src=00:88:99:aa:bb:cc actions=drop
EOF
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=10, in_port=2,dl_src=00:44:55:66:77:88 actions=apply_actions(drop)
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=apply_actions(drop)
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=apply_actions(drop)
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=apply_actions(drop)
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=apply_actions(drop)
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=apply_actions(drop)
 in_port=2,dl_src=00:55:66:77:88:99 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# Adding another flow will cause the one that expires soonest overall
# to be evicted.
AT_CHECK([ovs-ofctl add-flow br0 'idle_timeout=80 in_port=2 dl_src=00:99:aa:bb:cc:dd actions=drop'])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=30, in_port=1,dl_src=00:22:33:44:55:66 actions=apply_actions(drop)
 idle_timeout=40, in_port=1,dl_src=00:33:44:55:66:77 actions=apply_actions(drop)
 idle_timeout=50, in_port=2,dl_src=00:66:77:88:99:aa actions=apply_actions(drop)
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=apply_actions(drop)
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=apply_actions(drop)
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=apply_actions(drop)
 in_port=2,dl_src=00:55:66:77:88:99 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
# Reducing the flow limit also causes the flows that expire soonest
# overall to be evicted.
AT_CHECK([ovs-vsctl set Flow_Table evict flow-limit=4])
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0], [dnl
 idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=apply_actions(drop)
 idle_timeout=70, in_port=2,dl_src=00:88:99:aa:bb:cc actions=apply_actions(drop)
 idle_timeout=80, in_port=2,dl_src=00:99:aa:bb:cc:dd actions=apply_actions(drop)
 in_port=2,dl_src=00:55:66:77:88:99 actions=apply_actions(drop)
OFPST11_FLOW reply (OF1.2):
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([ofproto - asynchronous message control (OpenFlow 1.2)])
OVS_VSWITCHD_START
AT_CHECK([ovs-ofctl monitor br0 --detach --no-chdir --pidfile])
check_async () {
    printf '\n\n--- check_async %d ---\n\n\n' $1
    INDEX=$1
    shift

    ovs-appctl -t ovs-ofctl ofctl/barrier
    ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
    : > expout

    # OFPT_PACKET_IN, OFPR_ACTION (controller_id=0)
    ovs-ofctl -v packet-out br0 none controller '0001020304050010203040501234'
    if test X"$1" = X"OFPR_ACTION"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.2): total_len=14 in_port=NONE (via action) data_len=14 (unbuffered)
priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:1234,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)"
    fi

    # OFPT_PACKET_IN, OFPR_INVALID_TTL (controller_id=0)
    ovs-ofctl packet-out br0 none dec_ttl '002583dfb4000026b98cb0f908004500003fb7e200000011339bac11370dac100002d7730035002b8f6d86fb0100000100000000000006626c702d7873066e696369726103636f6d00000f00'
    if test X"$1" = X"OFPR_INVALID_TTL"; then shift;
        echo >>expout "OFPT_PACKET_IN (OF1.2): total_len=76 in_port=NONE (via invalid_ttl) data_len=76 (unbuffered)
priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:26:b9:8c:b0:f9->00:25:83:df:b4:00) type:0800,mpls(0) proto:17 tos:0 ttl:0 ip(172.17.55.13->172.16.0.2) port(55155->53) udp_csum:8f6d"
    fi

    # OFPT_PORT_STATUS, OFPPR_ADD
    ovs-vsctl add-port br0 test -- set Interface test type=dummy
    if test X"$1" = X"OFPPR_ADD"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.2): ADD: 1(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 100000 Mbps now, 100000 Mbps max"
    fi

    # OFPT_PORT_STATUS, OFPPR_DELETE
    ovs-vsctl del-port br0 test
    if test X"$1" = X"OFPPR_DELETE"; then shift;
        echo >>expout "OFPT_PORT_STATUS (OF1.2): DEL: 1(test): addr:aa:55:aa:55:00:0x
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 100000 Mbps now, 100000 Mbps max"
    fi

    # OFPT_FLOW_REMOVED, OFPRR_DELETE
    ovs-ofctl add-flow br0 send_flow_rem,actions=drop
    ovs-ofctl --strict del-flows br0 ''
    if test X"$1" = X"OFPRR_DELETE"; then shift;
        echo >>expout "OFPT_FLOW_REMOVED (OF1.2):  reason=delete"
    fi
    AT_FAIL_IF([test X"$1" != X])

    ovs-appctl -t ovs-ofctl ofctl/barrier
    echo >>expout "OFPT_BARRIER_REPLY (OF1.2):"

    AT_CHECK(
      [[sed '
s/ (xid=0x[0-9a-fA-F]*)//
s/ *duration.*//
s/00:0.$/00:0x/' < monitor.log]],
      [0], [expout])
}

# It's a service connection so initially there should be no async messages.
check_async 1

# Set miss_send_len to 128, turning on packet-ins for our service connection.
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
check_async 2 OFPR_ACTION OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

# Set miss_send_len to 128 and enable invalid_ttl.
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700040080
check_async 3 OFPR_ACTION OFPR_INVALID_TTL OFPPR_ADD OFPPR_DELETE OFPRR_DELETE

ovs-appctl -t ovs-ofctl exit
OVS_VSWITCHD_STOP
AT_CLEANUP


dnl This test checks that OFPT_PACKET_OUT accepts both OFPP_NONE (as
dnl specified by OpenFlow 1.2) and OFPP_CONTROLLER (used by some
dnl controllers despite the spec) as meaning a packet that was generated
dnl by the controller.
AT_SETUP([ofproto - packet-out from controller (OpenFlow 1.2)])
OVS_VSWITCHD_START

# Start a monitor listening for packet-ins.
AT_CHECK([ovs-ofctl monitor br0 --detach --no-chdir --pidfile])
ovs-appctl -t ovs-ofctl ofctl/send 0309000c0123456700000080
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl ofctl/set-output-file monitor.log
AT_CAPTURE_FILE([monitor.log])

# Send some packet-outs with OFPP_NONE and OFPP_CONTROLLER (4294967293) as in_port.
AT_CHECK([ovs-ofctl packet-out br0 none controller '0001020304050010203040501234'])
AT_CHECK([ovs-ofctl packet-out br0 4294967293 controller '0001020304050010203040505678'])

# Stop the monitor and check its output.
ovs-appctl -t ovs-ofctl ofctl/barrier
ovs-appctl -t ovs-ofctl exit

AT_CHECK([sed 's/ (xid=0x[[0-9a-fA-F]]*)//' monitor.log], [0], [dnl
OFPT_PACKET_IN (OF1.2): total_len=14 in_port=NONE (via action) data_len=14 (unbuffered)
priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:1234,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
OFPT_PACKET_IN (OF1.2): total_len=14 in_port=CONTROLLER (via action) data_len=14 (unbuffered)
priority:0,tunnel:0,in_port:0000,tci(0),qinq_tci(0) mac(00:10:20:30:40:50->00:01:02:03:04:05) type:5678,mpls(0) proto:0 tos:0 ttl:0 ip(0.0.0.0->0.0.0.0)
OFPT_BARRIER_REPLY (OF1.2):
])

OVS_VSWITCHD_STOP
AT_CLEANUP
